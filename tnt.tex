% Thesis: Typed Nomadic Time
% Author: Andrew Hughes

\chapter{Typed Nomadic Time}
\label{tnt}

\section{Introduction}

A type system is a common addition to a process calculus.  This is
especially true, when the intended use of the calculus is as the basis
for a programming language or a distributed system, which is the case
here.  In this final chapter of original research, we demonstrate how
Nomadic Time may be extended with a type system based on the notion of
groups (see \ref{typesys}) and how this may then be used in DynamiTE
(see \ref{dyn:type}).  Each process is assigned to a group, which then
determines which environs it may \emph{reside} in, \emph{open},
\emph{leave} or \emph{enter}.

Before we enter into the technicalities of how this system is
implemented, we first present some existing type systems used in other
process calculi, including the origins of this group-based system.

\section{Existing Typed Calculi}
\label{typedcalculi}

Type systems can be used to restrict the calculus in ways that aren't
always possible via mere manipulation of the syntax and semantics.
Adding a type system can be as simple as formalising implicit notions,
such as the use of $\ambin{m}$ as a capability and not as part of a
path \cite{ambienttypes} or the fact that the $x$ in $x(y)$ should be
represent a link and not a mere value \cite{sangiorgi:types-or}.  It
may also provide more complex intuitions, by distinguishing individual
entities, controlling mobility \cite{sangiorgi:mobsafeambients,
  ambienttypes} or resources \cite{hennessy:dpi98} or even providing a
full subtyping relation \cite{sangiorgi:typing, boxedamb02}.  This
section considers a few examples of such type systems for both the
$\pi$ calculus (\ref{pitypes}) and the ambient calculus
(\ref{ambienttypes}).\subsection{Type Systems for the $\pi$ Calculus}
\label{pitypes}

Various type systems have been introduced for the $\pi$ calculus in
the literature, ranging from the simple notion of sorts introduced by
Milner \cite{milner:pi} to those introduced for a specific purpose
\cite{sangiorgi:types-or} and more complex systems involving subtyping
\cite{sangiorgi:typing}.  Here, sorts are considered followed by a
brief look at the distinction between values and links made by
Sangiorgi \cite{sangiorgi:types-or} for the purpose of proving
termination.

\subsubsection{Sorts}
\label{sorts}

The earliest notion of types was introduced by Milner in
\cite{milner:93polyadic, milner:pi}.  The discipline of \emph{sorts}
is simply a way of representing `the length and nature of the vector
of names a name may carry in communication' \cite{milner:93polyadic}.
Formally, a sort is a partial function,

\begin{equation}
ob : \Sigma \rightarrow \Sigma^*
\end{equation}

\noindent mapping a name to a vector of names.  From this, it is
simple to define a sort for all communications in CCS and CaSE as
$\{NAME \mapsto ()\}$ (as nothing is passed) and the monadic $\pi$
calculus as $\{NAME \mapsto (NAME)\}$.

Take the simple example of a buffer,

\begin{equation}
  Buf \eqdef (in,out)(in(x).\overline{out}x.Buf\langle in,
  out\rangle 
\end{equation}

\noindent which simply receives a value on $in$ and transmits it on
$out$.  $x$ may be assigned the sort $s_1 \mapsto S$, where $S$ is the
unknown sort of the buffered value and $s_1$ is an arbitrary name for
the new sort.  From this, it follows that both the $in$ and $out$
channels have the sort $s_2 \mapsto (s_1)$, as they both receive or
transmit $x$.

The purpose behind introducing sorts is to make explicit the need to
match the number of values being received with the number being sent.
Matching the length of these vectors becomes a necessity when dealing
with the polyadic $\pi$ calculus, which doesn't have the same uniform
sort for all channels as is present in CCS, CaSE or the $\pi$
calculus.

Consider the example from \cite{milner:pi} of two processes, $P$ and
$Q$:

\begin{align}
P & \eqdef x(y).\overline{y}uv.\nil \\
Q & \eqdef \overline{x}y'.y'(w).Q' 
\end{align}

\noindent where the parallel composition of these two processes should
be disallowed.  This is made clear following the first reduction that
would result from such a composition:

\begin{equation}
P \pc Q \rightarrow \overline{y'}uv.\nil \pc y'(w).Q'
\end{equation}

\noindent where $Q$ transmits $y'$ to $P$.  $P$ then tries to use $y'$
to transmit two values, $u$ and $v$, whereas $y'$ is only used with
one, $w$, in the input of $Q$.  Applying an appropriate sort discipline,

\begin{equation}
\begin{aligned}
u: s_1 & \mapsto S \\
v: s_2 & \mapsto T \\
w: s_3 & \mapsto (s_1) \\
y: s_4 & \mapsto (s_1, s_2) \\
y': s_5 & \mapsto (s_1)
\end{aligned}
\end{equation}

\noindent allows the typing of $x$ to be prevented by distinguishing
between types based on the length of the sort.  In $P$, $x$ must have
a sort of length two, while in $Q$, its sort would only be of length
one.  This kind of type system formalises an intuition already adopted
implicitly (that the length of the input vector should equal that of
the output vector), which is a common methodology for type systems.

\subsubsection{Typing for Termination}

A similar realisation of implicit assumptions is made by Sangiorgi
\cite{sangiorgi:types-or} and is used to prove termination for a
subset of possible $\pi$ calculus processes.  The type system is used
to explicitly realise the \emph{order} of a name.  The types use the
simple grammar,

\begin{equation}
T ::= \#T \pc unit
\end{equation}

\noindent where $unit$ represents a value and a series of $\#$ symbols
is used to represent the level of indirection which exists between the
value and the current name.  For example, $\#unit$ is the type of a
\emph{first-order link}, representing a name which is used to pass
values between processes.  A type with more than one $\#$ represents a
\emph{higher-order link}, which is used to pass links between
processes.

This notion is used within the fragment of the type system shown in
Table \ref{tab:sangrules} to restrict the possible types used in input
and output prefixing, and restriction.  The rule T-Out ensures
that an output prefix, $\overline{v}w.M$, is only typeable if:

\begin{table}
  \caption{Typing Rules from \cite{sangiorgi:types-or}}
  \label{tab:sangrules}
  \shrule
 \begin{center}
 \begin{tabular}{c}
     \Rule{\sc{T-Out}\ \ }
     {\vdash v : \#T, \vdash w : T, \vdash M}
     {\vdash \overline{v}w.M}
     {}
  \\[3ex]
  \Rule{\sc{T-Inp}\ }
     {\vdash v : \#T, x \in T, \vdash M}
     {\vdash v(x).M}
     {}
  \\[3ex]
     \Rule{\sc{T-Res}\ \ }
     {x_i \in \#T_i\ \text{for some}\ T_i (1 \le i \le n), \vdash M}
     {\vdash (x_1 \dots x_n) M}
     {}
 \end{tabular}
  \end{center}
  \shrule
\end{table}

\begin{itemize}
\item $v$ is at least a first-order link (it has one or more $\#$s)
\item $w$ has a type, $T$
\item The continuation, $M$, is typeable
\end{itemize}

\noindent which prevents $v$ from being a simple value.  Similarly,
T-In restricts $v$ to being at least a first-order link in
$v(x).M$ and T-Res ensures that each restricted name is a link.

These are all ideas that are adopted implicitly in using the $\pi$
calculus to model systems, but, when not enforced by a type system,
these properties can not be included in proofs.  The type system in
Sangiorgi's paper, although simple, allows a set of processes which
are syntactically correct, but logically flawed, to be excluded by
only considering processes which are typeable.

%\subsubsection{The Type System of the Distributed $\pi$ Calculus}

\subsection{Type Systems for the Ambient Calculus}
\label{ambienttypes}

Early work \cite{commtypesamb} on providing a type system for the
ambient calculus focused on typing the derived communication primitives
and specifically the values being exchanged.  While interesting, this
doesn't really relate to the focus of the calculus, spatial mobility.
In \cite{cardelli:typesforambients, cardelli:ambienttypes}, a first
attempt is made at providing types for mobility, via mobility and locking
annotations.  Mobility annotations are used to mark an ambient as mobile
($\underline{\vee}$) or immobile ($\curvearrowright$), where mobile
ambients may be involved in movement operations using the capabilities
$in$ and $out$.  Locking annotations control the use of $open$; locked
ambients ($\bullet$) may not be the target of an $open$ capability,
while unlocked ambients ($\circ$) may.

A more general theory is given in \cite{ambienttypes} with the
introduction of \emph{groups}.  Rather than simply specifying whether or
not an ambient can move or be destroyed, the type system is more
specific as to which ambients may effect others.  To avoid dependent
types \cite{deptypes}, where the types are dependent on the values being
typed, an intermediary notion of a group is introduced.  This is also
advantageous in that it allows a series of ambients to have the same
typing, while typing in relation to a single ambient is still possible
by having a group with only one member.

For example, given two ambients $m$ and $n$, the types should express
that $n$ can enter $m$.  A dependent formalisation would say that $n$
has the type $CanEnter(m)$, while, using groups, $m$ is given the type
$G$ (where $G$ is a group) and $n$ is typed as $CanEnter(G)$.  Within
the type system itself, ambients are allocated to groups via the use of
a group binder, $(\nu G)$.  Just like the ambient binder, $(\nu n)$,
the scope of this may extrude outwards.  However, the type system
prevents it from ever encapsulating ambients which did not form part of
its initial scope (i.e. it only tracks the movements of ambients that
are a member of that group).  Within the paper, groups are used to
assign properties to its members, such as the type of communication
possible and the control of crossing or opening ambients.

The types of messages or \emph{exchanges} may specify either no
communication ($Shh$) or a tuple of partners for the communication:

\begin{equation}
S, T ::= Shh \pc W_1 \times \dots \times W_k
\end{equation}

\noindent For example, in the simplest form of the calculus,
$Agent[Shh]$ represents a group called $Agent$, the members of which may
not exchange values.  Nesting is possible, so $Place[Agent[Shh]]]$
represents a $Place$ where groups of $Agent$s may stay and continue to
be silent.

The full type system, given in \cite{ambienttypes}, includes these
exchange types along with types to control the opening and crossing of
ambients.  Groups are parameterised over $F$,

\begin{equation}
F ::= ^\curvearrowright \mathbf{G}, ^\circ \mathbf{H}, T
\end{equation}

\noindent with the final form of ambient type being $G^\curvearrowright
\mathbf{G'}[F]$.  $\mathbf{G'}$ represents the groups that the ambient
may cross via objective moves (introduced in the same paper), while
$\mathbf{G}$ includes the groups that the ambient may cross via standard
subjective movement.  Finally, $\mathbf{H}$ distinguishes the groups
whose ambients may be $\ambopen{e}$, while $T$ is as defined above.

A similar system is adopted in \cite{m3}, but, as this refers to boxed
ambients (see \ref{ambvariants}), no control of $open$ is required.  It
does introduce a new set of groups, however, to handle the lightweight
process mobility presented.  In both cases, the type system has a
positive effect on the calculus.  Not only does it alleviate some of
the syntax ambiguity, but it also allows a more fine-grained notion of
mobility, where specific ambients can be made immobile or unable to
cross a particular ambient.

Type systems were also briefly considered as a way of restricting the
behaviour of a process algebraic model.  These tend to explicitly reduce
the expressivity of the formalism in order to ensure that unwanted
constructs can not be created by making them untypeable.  This also
makes it easier to prove properties of the calculus.  

\section{A Type System for Nomadic Time}
\label{typesys}

In this section, we consider the specification of a simple type
system for Nomadic Time, which fulfils two main goals:

\begin{enumerate}
\item It ensures the sanity of a given syntactic construction, which
  is implicit in the earlier examples.  This is primarily achieved by
  ensuring that normal process primitives and the primitives used by
  bouncers remain distinct.  For example, $\tntin{n}.\bin.\nil$ should
  not be a valid bouncer, especially as $\tntin{n}$ suggests that the
  bouncer (and its environ) should move inside $n$.
\item It extends and refines our control over mobility by adding a
      secondary mechanism orthogonal to the use of bouncers.
\end{enumerate}

Our rudimentary type system is inspired in part by those given for the
ambient calculus (see \ref{ambienttypes}), specifically the notion of
groups presented in \cite{ambienttypes} and \cite{m3}.  Each process is
assigned a group type, which determines the use of the mobility
primitives.  Each group is a tuple comprising four sets of environ
names\footnote{Each group $g$ is defined abstractly to be of kind
$Group$.}:

\begin{tabular}{rlcl}
$\quad \bullet$ & $\mathscr{R}$ & -- & Environs in which the process may
 \emph{reside} \\
$\bullet$ & $\mathscr{O}$ & -- & Environs which it may \emph{open} \\
$\bullet$ & $\mathscr{L}$ & -- & Environs which it may \emph{leave} \\
$\bullet$ & $\mathscr{E}$ & -- & Environs which it may \emph{enter}
\end{tabular}

$\mathscr{L}$ and $\mathscr{E}$ form subsets of $\mathscr{R}$, as
clearly, if a process may enter or leave a environ, it must also be able
to reside within it.  As an example, consider the group
$(\{n\},\emptyset, \emptyset,\{n\})$.  Processes of this type may enter
and reside in $n$, but, once there, they may not leave.  They also lack
the ability to destroy $n$.  We write $g(\mathscr{R})$,
$g(\mathscr{O})$, $g(\mathscr{L})$ and $g(\mathscr{E})$ for the
components of the group $g$.

The type system is presented in Table \ref{tab:basictypes}; the general
syntax for a type $T$ is given by

\begin{equation*}
\label{eqn:tnt:typesyntax}
\begin{aligned}
T \mathrel{::=} & \quad P \mid Act \mid Clock \mid Name \mid Bouncer \mid
 Environ \\
P \mathrel{::=} & \quad g \mid P \oplus P \mid P \otimes P \mid \pi_L P \mid
 \pi_R P \\
                & \quad \text{where $g \colon Group$ ranges over group types.}
\end{aligned}
\end{equation*}

The rule $Env$ states that if $\xi$ of type $T$ is a member of
$\Gamma$, then a typing derivation $\vdash \xi : T$ may be made in the
context of $\Gamma$.  This forms the basis of all later rules.  Notice
that our system is naturally polymorphic; both $\nil$ and $\Delta$ can
have any group type $g$.  In contrast, $\Omega$ can only be typed as a
$Bouncer$, thus distinguishing it from the behaviourally equivalent
process, $\Delta$.  

The remaining rules allow types to be applied in accordance with the
various operators present in the calculus.  Notice that $Stall$ requires
that $\sigma$ is typeable as a clock, another restriction which makes
explicit a number of issues implied in the syntax.  Similarly, $Act$
requires $\alpha$ to be an action ($Act$) and $Res$ requires the $a$ to
be a $Name$.  When handing the binary operators, we use the rules $SumC$
and $ParC$ to construct appropriate composite types that maintain the
groups used on either side.  The rules $SumL$ and $SumR$ then allow the
appropriate type to be recovered when one of the processes in a
summation evolves.  Notice that no construct is available (none is
needed) for recovering the components of a product type in this system.

\begin{table}
  \caption{Types}
  \label{tab:basictypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
     \Rule{Env}
     {\xi : T \in \Gamma}
     {\Gamma \vdash \xi : T}
     {}
  &
  \Rule{Nil}
     {\Gamma \vdash g : Group}
     {\Gamma \vdash \nil : g}
     {}
  \\[3ex]
     \Rule{BNil}
     {-}
     {\Gamma \vdash \Omega : Bouncer}
     {}
     &
     \Rule{Stop}
     {\Gamma \vdash g : Group}
     {\Gamma \vdash \Delta : g}
     {}
     \\[3ex]
     \Rule{Stall}
     {\Gamma \vdash \sigma : Clock, g : Group}
     {\Gamma \vdash \Delta_\sigma : g}
     {}
     &
     \Rule{Act}
     {\Gamma \vdash \alpha : Act, E : g : Group}
     {\Gamma \vdash \alpha . E : g}
     {}
  \\[3ex]
     \Rule{Rec}
     {\Gamma \vdash E : g : Group}
     {\Gamma \vdash \mu X.E : g}
     {}
     &
     \Rule{Res}
     {\Gamma \vdash a : Name, E : g : Group}
     {\Gamma \vdash E \res{a} : g}
     {}
  \\[3ex]
   \Rule{SumC}
   {\Gamma \vdash E : g : Group, F : g' : Group}
   {\Gamma \vdash E + F : g \oplus g'}
   {}
   &
   \Rule{ParC}
   {\Gamma \vdash E : g : Group, F : g' : Group}
   {\Gamma \vdash E \pc F : g \otimes g'}
   {}
   \\[3ex]
   \Rule{SumL}
   {\Gamma \vdash E + F : g : Group}
   {\Gamma \vdash E' : \pi_{L} g}
   {(E \derives{\kappa} E')}
   &
   \Rule{SumR}
   {\Gamma \vdash E + F : g : Group}
   {\Gamma \vdash F' : \pi_{R} g}
   {(F \derives{\kappa} F')}
   \\[3ex]
 \end{tabular}
  \end{center}
  \shrule
\end{table}

Table \ref{tab:totypes} shows the rules for timeouts.  These follow much
the same design as the rules for the summation operator, except that
they include the additional requirement that $\sigma$ must be typeable
as a clock.  The $STOS$ rule handles the additional eventuality that the
process may evolve with the timeout still in place when using the stable
timeout operator.
 
\begin{table}
  \caption{Timeout Types}
  \label{tab:totypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
  \multicolumn{4}{c}{
   \Rulea{FTOC}
   {\Gamma \vdash E : g : Group, F : g' : Group, \sigma : Clock}
   {\Gamma \vdash \timeout{E}{\sigma}{F} : g \oplus g'}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{STOC}
   {\Gamma \vdash E : g : Group, F : g' : Group, \sigma : Clock}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g \oplus g'}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{FTOL}
   {\Gamma \vdash \timeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash E' : \pi_{L} g}
   {(E \derives{\gamma} E', \gamma \ne \sigma)}
}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{FTOR}
   {\Gamma \vdash \timeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash F : \pi_{R} g}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{STOL}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash E' : \pi_{L} g}
   {(E \derives{\kappa} E')}
  }\\[3ex]
  \multicolumn{4}{c}{
   \Rulea{STOR}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash F : \pi_{R} g}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
  \Rulea{STOS}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash \stimeout{E'}{\sigma}{F} : g}
   {(E \derives{\rho} E', \rho \ne \sigma)}
  }
  \\[3ex]
 \end{tabular}
  \end{center}
  \shrule
\end{table}

The rules for the bouncers are shown in Table \ref{tab:botypes}, where
$BRec$ allows recursive bouncers to be defined, while $BIn$, $BOut$ and
$BOpen$ allow an existing bouncer, $B$, to be prefixed with one of the
three bouncer primitives ($\bin$, $\bout$ and $\bopen$).  $BSum$ simply
allows the result of composing two bouncers with the summation operator,
$+$ to be typeable as well.

\begin{table}
  \caption{Bouncer Types}
  \label{tab:botypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
  \Rule{BRec}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \mu X.B : Bouncer}
  {}
  &
  \Rule{BIn}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bin .B : Bouncer}
  {}
  \\[3ex]
  \Rule{BOut}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bout .B : Bouncer}
  {}
  &
  \Rule{BOpen}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bopen .B : Bouncer}
  {}
  \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{BSum}
   {\Gamma \cup \Gamma^\prime \vdash B : Bouncer,
   \Gamma \cup \Gamma^\prime  \vdash B^\prime : Bouncer}
   {\Gamma \cup \Gamma^\prime \vdash B + B^\prime : Bouncer}
   {}
  }
 \end{tabular}
  \end{center}
  \shrule
\end{table}
 
The mobility types in Table \ref{tab:mobtypes} form the remaining focus
of our type system; the type $g$ of an environ
$\locv{m}{E}{B}{\vec{\sigma}}$ is that of its encapsulated process $E$,
subject to the constraint $m \in g(\mathscr{R})$. Similar sanity checks
are performed in the other rules. For example, in $Open$, $E$ is the
process that performs the mobility primitive, $\tntopen{m}$ (subject to
the constraint $m \in g(\mathscr{O})$).  However, the destruction of $m$
also has an effect on its process ($F$).  As a result, $F$ must have an
appropriate type, $h$, such that $F$ can reside in the parent environ,
$n$, after $m$ is removed.

\begin{table}
  \caption{Mobility Types}
  \label{tab:mobtypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
  \multicolumn{4}{c}{
     \Rulea{Environ}
     {\Gamma \vdash m : Environ,
     \Gamma \vdash E : g : Group,
     \Gamma \vdash B : Bouncer,
     m \in g(\mathscr{R})}
     {\Gamma \vdash \loc{m}{E}{B}{\vec{\sigma}} : g}
     {}
  }
  \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{EnvIn}
     { \Gamma \vdash m : Environ,
       \Gamma \vdash E : g : Group,
       m \in g(\mathscr{E})}
     {\Gamma \vdash \tntin{m}.E : g}
     {}
  }
     \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{EnvOut}
     {\Gamma \vdash \loc{n}{\loc{m}{E}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group,
  m \in g(\mathscr{L}),
  n \in g(\mathscr{E})}
     {\Gamma \vdash \tntout{m}.E : g}
     {}
  }
     \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{Open}
     {\Gamma \vdash \loc{n}{E}{B_1}{\vec{\sigma}} : g : Group,
  \Gamma \vdash \loc{m}{F}{B}{\vec{\sigma}} : h : Group,
  m \in g(\mathscr{O}),
  n \in h(\mathscr{E})}
     {\Gamma \vdash \tntopen{m}.E : g}
     {}
  }
  \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{ProcIn}
  {\Gamma \vdash a : Name,
  \Gamma \vdash \loc{n}{E \mid F \mid \loc{m}{\nil}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group, 
  m \in g(\mathscr{E})}
     {\loc{n}{\procin{a}{m}.E \mid a.F \mid \loc{m}{\nil}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group}
     {}  
  }
  \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{ProcOut}
  {\Gamma \vdash a : Name,
  \Gamma \vdash \locv{n}{\loc{m}{E \mid F}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group, 
  m \in g(\mathscr{L}),
  n \in g(\mathscr{E})}
     {\Gamma \vdash \locv{n}{\loc{m}{\procout{a}{m}.E \mid a.F}{B}{\vec{\sigma}}}{B_2}{\vec{\rho}} :
  g}
     {}
  }
 \end{tabular}
  \end{center}
  \shrule
\end{table}

\section{DynamiTE and the Type System}
\label{dyn:type}

Extending DynamiTE to support the type system of Typed Nomadic Time
(TNT), and type systems in general is relatively simple.  We first
extend the \texttt{Process} interface to create a new interface,
\texttt{TypedProcess}:

\begin{verbatim}
public interface TypedProcess
  extends Process
{
  Type getType()
    throws UntypeableProcessException;
}
\end{verbatim}

With \texttt{TypedProcess}, we extend the contract for implementing a
process by one method: \texttt{getType}.  This either returns the type
of the process, or throws an exception if the process is untypeable.
The type of a process is represented by a new hierarchy of classes,
all of which implement the \texttt{Type} marker interface.  Thus, in
the same way the syntax of a calculus is represented as a set of
classes which implement \texttt{Process}, so its type system is
represented by a set of classes which implement \texttt{Type}.  The
\texttt{Calculus} interface (introduced in \ref{dyn:plugin}) becomes:

\begin{verbatim}
public interface Calculus
  extends Probeable
{
  public Collection<Class<? extends Process>> getSyntax();
  public Collection<Class<? extends Type>> getTypeSystem();
  public Label getLabel(String label);
}
\end{verbatim}

The methods \texttt{getSyntax} and \texttt{getLabel(String)} were both
provided before, and return the syntax and transition labels for the
calculus respectively, the latter also acting as a validation
mechanism.  The new method is \texttt{getTypeSystem} which returns the
classes that represents valid types; for TNT, \texttt{getTypeSystem}
represents $T$ (see \ref{eqn:tnt:typesyntax}) just as
\texttt{getSyntax} represents the process terms $E$ and $F$ (see
\ref{eqn:nt:syntax}).  We implement the method for TNT as follows:

\begin{verbatim}
  public Collection<Class<? extends Type>> getTypeSystem()
  {
    Set<Class<? extends Type>> types =
      new HashSet<Class<? extends Type>>();
    types.add(ProcessType.class);
    types.add(ActionType.class);
    types.add(ClockType.class);
    types.add(NameType.class);
    types.add(BouncerType.class);
    types.add(EnvironType.class);
    return types;
  }
\end{verbatim}

The classes have a common suffix of `Type' to avoid conflicts with the
syntax classes.  All but \texttt{ProcessType} are simple classes with
a singleton instance for that type.  To represent $P$, there are three
further classes: \texttt{Group}, \texttt{SumType} and
\texttt{ProdType}; we dispense with $\pi_L P$ and $\pi_R P$ for the
implementation as we can obtain the group directly from the
appropriate composed process.  To handle the constraints imposed by
group membership, such as $m \in g(\mathscr{E})$, \texttt{ProcessType}
requires its subclasses to implement the follow methods:

\begin{verbatim}
public interface ProcessType
  extends Type
{
  boolean canResideIn(String environ);
  boolean canOpen(String environ);
  boolean canLeave(String environ);
  boolean canEnter(String environ);
}
\end{verbatim}

These are implemented in \texttt{Group} using sets provided by the
user.  For \texttt{SumType}, the environ name must appear in either of
the composed groups, and for \texttt{ProdType}, it must appear in
both, thus being a member of the Cartesian product of the two sets.
The implementations of \texttt{getType} for each process term follow
fairly straightforwardly from the type system given in
\ref{tab:basictypes}, \ref{tab:totypes}, \ref{tab:botypes} and
\ref{tab:mobtypes}.  For instance, implementing $BNil$ is just a
matter of adding the following method to the \texttt{Omega} class:

\begin{verbatim}
public Type getType()
{
  return BouncerType.BOUNCER;
}
\end{verbatim}

Those which contain the $g : Group$ prerequisite are more complicated.
Just as with names, clocks and environs, the available groups are
created by the user and registered with the \texttt{Context}.  To
create the association between a process and a group to begin with,
the classes \texttt{Nil}, \texttt{Delta} and \texttt{Stall} (those
that don't contain an instance of \texttt{Process}) gain an additional
constructor which records the group of the process.  This has the
effect of making \texttt{Nil} and \texttt{Delta} no longer singletons.
Instead, the class is implemented as follows:

\begin{verbatim}
public class Delta
  extends Process
{
  public static final Delta DELTA = new Delta();

  private Delta() 
  { 
    this(null); 
  }
  
  public Delta(Group g) 
  { 
    this.g = g; 
  }

  public Type getType()
  {
    return g;
  }
}
\end{verbatim}

We still allow instances of these classes to be constructed without a
group (\texttt{getType()} will return \texttt{null}) so as to still
support Nomadic Time.  The other classes likewise implement
\texttt{getType()} in accordance with the typing rules, so that the
group of the overall process is derived from that of its constituents.
For example, the implementation for \texttt{Sum} looks like this:

\begin{verbatim}
public Type getType()
{
  return new SumType(left.getType(), right.getType());
}
\end{verbatim}

\noindent where \texttt{left} and \texttt{right} are the processes
composed by the $+$ operator.

All the implementations of \texttt{getType()} we have shown so far
always succeed.  This is not the case with the mobility typing rules
implemented in subclasses of \texttt{ModPrefix}.  For example, we
implement \texttt{getType()} in \texttt{InEnv} as follows:

\begin{verbatim}
public Type getType()
{
  ProcessType procType = proc.getType();  
  if (EnvironType.isEnviron(env) &&
      procType != null &&
      procType.canEnter(env))
  {
    return procType;
  }
  else
  {
    throw new UntypeableProcessException(this);
  }
}
 
\end{verbatim}

\noindent In the above, the call to \texttt{EnvironType.isEnviron}
corresponds to $\Gamma \vdash m : Environ$ and checks that the given
name has been registered as an environ.  We could do such a check
directly, but this method allows the means of ensuring $\Gamma \vdash
m : Environ$ to change without effecting every \texttt{getType()}
implementation.  The call to \texttt{procType.canEnter(String)}
ensures that $m \in g(\mathscr{E})$ holds.  The actual code executed
by the call depends on the type of \texttt{procType}; for a
\texttt{Group}, the check only searchs the single $\mathcal{E}$ set
belonging to that group, but for \texttt{ProdType}, it must ensure
that $m$ is in the $\mathcal{E}$ set of both composed groups.

Finally, the type checks may be performed at runtime by an evolver
that supports them.  We add an additional interface,
\texttt{TypedEvolver} to correspond to \texttt{TypedProcess}:

\begin{verbatim}
public interface TypedEvolver
{
  void evolve(TypedProcess p);
}
\end{verbatim}

\noindent When the checks are made and how the evolver reacts to them
are left up to each implementation.

\section{Conclusion}

In this chapter, we consider a number of type systems from the
literature, including the use of sorts for typing communication (see
\ref{sorts}) and the use of groups to restrict ambient movement (see
\ref{ambienttypes}).  We then adapted the later to create a type
system for Nomadic Time, resulting in the typed variant Typed Nomadic
Time or TNT (see \ref{typesys}). Finally, we showed how DynamiTE could
be modified to support this (see \ref{dyn:type}).  To conclude, we
believe that our type system provides a useful optional addition to
the calculus.  It can be employed, when needed, to provide a finer
level of access control than the simple approach of enumerating
possible actions, as used by bouncers.  There are possibilities for
extending the type system further, which we will cover as part of the
next and final chapter on future work.
