% Thesis: Typed Nomadic Time
% Author: Andrew Hughes

\chapter{Typed Nomadic Time}
\label{tnt}

\section{Introduction}

A type system is a common addition to a process calculus.  This is
especially true, when the intended use of the calculus is as the basis
for a programming language or a distributed system, which is the case
here.  In this final chapter of original research, we demonstrate how
Nomadic Time may be extended with a type system based on the notion of
groups.  Each process is assigned to a group, which then determines
which environs it may \emph{reside} in, \emph{open}, \emph{leave} or
\emph{enter}.

Before we enter into the technicalities of how this system is
implemented, we first present some existing type systems used in other
process calculi, including the origins of this group-based system.

\section{Existing Typed Calculi}
\label{typedcalculi}

Type systems can be used to restrict the calculus in ways that aren't
always possible via mere manipulation of the syntax and semantics.
Adding a type system can be as simple as formalising implicit notions,
such as the use of $\ambin{m}$ as a capability and not as part of a
path \cite{ambienttypes} or the fact that the $x$ in $x(y)$ should be
represent a link and not a mere value \cite{sangiorgi:types-or}.  It
may also provide more complex intuitions, by distinguishing individual
entities, controlling mobility \cite{sangiorgi:mobsafeambients,
  ambienttypes} or resources \cite{hennessy:dpi98} or even providing a
full subtyping relation \cite{sangiorgi:typing, boxedamb02}.  This
section considers a few examples of such type systems for both the
$\pi$ calculus (\ref{pitypes}) and the ambient calculus
(\ref{ambienttypes}).

\subsection{Type Systems for the $\pi$ Calculus}
\label{pitypes}

Various type systems have been introduced for the $\pi$ calculus in
the literature, ranging from the simple notion of sorts introduced by
Milner \cite{milner:pi} to those introduced for a specific purpose
\cite{sangiorgi:types-or} and more complex systems involving subtyping
\cite{sangiorgi:typing}.  Here, sorts are considered followed by a
brief look at the distinction between values and links made by
Sangiorgi \cite{sangiorgi:types-or} for the purpose of proving
termination.

\subsubsection{Sorts}
\label{sorts}

The earliest notion of types was introduced by Milner in
\cite{milner:93polyadic, milner:pi}.  The discipline of \emph{sorts}
is simply a way of representing `the length and nature of the vector
of names a name may carry in communication' \cite{milner:93polyadic}.
Formally, a sort is a partial function,

\begin{equation}
ob : \Sigma \rightarrow \Sigma^*
\end{equation}

\noindent mapping a name to a vector of names.  From this, it is
simple to define a sort for all communications in CCS and CaSE as
$\{NAME \mapsto ()\}$ (as nothing is passed) and the monadic $\pi$
calculus as $\{NAME \mapsto (NAME)\}$.

Take the simple example of a buffer,

\begin{equation}
  Buf \eqdef (in,out)(in(x).\overline{out}x.Buf\langle in,
  out\rangle 
\end{equation}

\noindent which simply receives a value on $in$ and transmits it on
$out$.  $x$ may be assigned the sort $s_1 \mapsto S$, where $S$ is the
unknown sort of the buffered value and $s_1$ is an arbitrary name for
the new sort.  From this, it follows that both the $in$ and $out$
channels have the sort $s_2 \mapsto (s_1)$, as they both receive or
transmit $x$.

The purpose behind introducing sorts is to make explicit the need to
match the number of values being received with the number being sent.
Matching the length of these vectors becomes a necessity when dealing
with the polyadic $\pi$ calculus, which doesn't have the same uniform
sort for all channels as is present in CCS, CaSE or the $\pi$
calculus.

Consider the example from \cite{milner:pi} of two processes, $P$ and
$Q$:

\begin{align}
P & \eqdef x(y).\overline{y}uv.\nil \\
Q & \eqdef \overline{x}y'.y'(w).Q' 
\end{align}

\noindent where the parallel composition of these two processes should
be disallowed.  This is made clear following the first reduction that
would result from such a composition:

\begin{equation}
P \pc Q \rightarrow \overline{y'}uv.\nil \pc y'(w).Q'
\end{equation}

\noindent where $Q$ transmits $y'$ to $P$.  $P$ then tries to use $y'$
to transmit two values, $u$ and $v$, whereas $y'$ is only used with
one, $w$, in the input of $Q$.  Applying an appropriate sort discipline,

\begin{equation}
\begin{aligned}
u: s_1 & \mapsto S \\
v: s_2 & \mapsto T \\
w: s_3 & \mapsto (s_1) \\
y: s_4 & \mapsto (s_1, s_2) \\
y': s_5 & \mapsto (s_1)
\end{aligned}
\end{equation}

\noindent allows the typing of $x$ to be prevented by distinguishing
between types based on the length of the sort.  In $P$, $x$ must have
a sort of length two, while in $Q$, its sort would only be of length
one.  This kind of type system formalises an intuition already adopted
implicitly (that the length of the input vector should equal that of
the output vector), which is a common methodology for type systems.

\subsubsection{Typing for Termination}

A similar realisation of implicit assumptions is made by Sangiorgi
\cite{sangiorgi:types-or} and is used to prove termination for a
subset of possible $\pi$ calculus processes.  The type system is used
to explicitly realise the \emph{order} of a name.  The types use the
simple grammar,

\begin{equation}
T ::= \#T \pc unit
\end{equation}

\noindent where $unit$ represents a value and a series of $\#$ symbols
is used to represent the level of indirection which exists between the
value and the current name.  For example, $\#unit$ is the type of a
\emph{first-order link}, representing a name which is used to pass
values between processes.  A type with more than one $\#$ represents a
\emph{higher-order link}, which is used to pass links between
processes.

This notion is used within the fragment of the type system shown in
Table \ref{tab:sangrules} to restrict the possible types used in input
and output prefixing, and restriction.  The rule T-Out ensures
that an output prefix, $\overline{v}w.M$, is only typeable if:

\begin{table}
  \caption{Typing Rules from \cite{sangiorgi:types-or}}
  \label{tab:sangrules}
  \shrule
 \begin{center}
 \begin{tabular}{c}
     \Rule{\sc{T-Out}\ \ }
     {\vdash v : \#T, \vdash w : T, \vdash M}
     {\vdash \overline{v}w.M}
     {}
  \\[3ex]
  \Rule{\sc{T-Inp}\ }
     {\vdash v : \#T, x \in T, \vdash M}
     {\vdash v(x).M}
     {}
  \\[3ex]
     \Rule{\sc{T-Res}\ \ }
     {x_i \in \#T_i\ \text{for some}\ T_i (1 \le i \le n), \vdash M}
     {\vdash (x_1 \dots x_n) M}
     {}
 \end{tabular}
  \end{center}
  \shrule
\end{table}

\begin{itemize}
\item $v$ is at least a first-order link (it has one or more $\#$s)
\item $w$ has a type, $T$
\item The continuation, $M$, is typeable
\end{itemize}

\noindent which prevents $v$ from being a simple value.  Similarly,
T-In restricts $v$ to being at least a first-order link in
$v(x).M$ and T-Res ensures that each restricted name is a link.

These are all ideas that are adopted implicitly in using the $\pi$
calculus to model systems, but, when not enforced by a type system,
these properties can not be included in proofs.  The type system in
Sangiorgi's paper, although simple, allows a set of processes which
are syntactically correct, but logically flawed, to be excluded by
only considering processes which are typeable.

%\subsubsection{The Type System of the Distributed $\pi$ Calculus}

\subsection{Type Systems for the Ambient Calculus}
\label{ambienttypes}

Early work \cite{commtypesamb} on providing a type system for the
ambient calculus focused on typing the derived communication primitives
and specifically the values being exchanged.  While interesting, this
doesn't really relate to the focus of the calculus, spatial mobility.
In \cite{cardelli:typesforambients, cardelli:ambienttypes}, a first
attempt is made at providing types for mobility, via mobility and locking
annotations.  Mobility annotations are used to mark an ambient as mobile
($\underline{\vee}$) or immobile ($\curvearrowright$), where mobile
ambients may be involved in movement operations using the capabilities
$in$ and $out$.  Locking annotations control the use of $open$; locked
ambients ($\bullet$) may not be the target of an $open$ capability,
while unlocked ambients ($\circ$) may.

A more general theory is given in \cite{ambienttypes} with the
introduction of \emph{groups}.  Rather than simply specifying whether or
not an ambient can move or be destroyed, the type system is more
specific as to which ambients may effect others.  To avoid dependent
types \cite{deptypes}, where the types are dependent on the values being
typed, an intermediary notion of a group is introduced.  This is also
advantageous in that it allows a series of ambients to have the same
typing, while typing in relation to a single ambient is still possible
by having a group with only one member.

For example, given two ambients $m$ and $n$, the types should express
that $n$ can enter $m$.  A dependent formalisation would say that $n$
has the type $CanEnter(m)$, while, using groups, $m$ is given the type
$G$ (where $G$ is a group) and $n$ is typed as $CanEnter(G)$.  Within
the type system itself, ambients are allocated to groups via the use of
a group binder, $(\nu G)$.  Just like the ambient binder, $(\nu n)$,
the scope of this may extrude outwards.  However, the type system
prevents it from ever encapsulating ambients which did not form part of
its initial scope (i.e. it only tracks the movements of ambients that
are a member of that group).  Within the paper, groups are used to
assign properties to its members, such as the type of communication
possible and the control of crossing or opening ambients.

The types of messages or \emph{exchanges} may specify either no
communication ($Shh$) or a tuple of partners for the communication:

\begin{equation}
S, T ::= Shh \pc W_1 \times \dots \times W_k
\end{equation}

\noindent For example, in the simplest form of the calculus,
$Agent[Shh]$ represents a group called $Agent$, the members of which may
not exchange values.  Nesting is possible, so $Place[Agent[Shh]]]$
represents a $Place$ where groups of $Agent$s may stay and continue to
be silent.

The full type system, given in \cite{ambienttypes}, includes these
exchange types along with types to control the opening and crossing of
ambients.  Groups are parameterised over $F$,

\begin{equation}
F ::= ^\curvearrowright \mathbf{G}, ^\circ \mathbf{H}, T
\end{equation}

\noindent with the final form of ambient type being $G^\curvearrowright
\mathbf{G'}[F]$.  $\mathbf{G'}$ represents the groups that the ambient
may cross via objective moves (introduced in the same paper), while
$\mathbf{G}$ includes the groups that the ambient may cross via standard
subjective movement.  Finally, $\mathbf{H}$ distinguishes the groups
whose ambients may be $\ambopen{e}$, while $T$ is as defined above.

A similar system is adopted in \cite{m3}, but, as this refers to boxed
ambients (see \ref{ambvariants}), no control of $open$ is required.  It
does introduce a new set of groups, however, to handle the lightweight
process mobility presented.  In both cases, the type system has a
positive effect on the calculus.  Not only does it alleviate some of
the syntax ambiguity, but it also allows a more fine-grained notion of
mobility, where specific ambients can be made immobile or unable to
cross a particular ambient.

Type systems were also briefly considered as a way of restricting the
behaviour of a process algebraic model.  These tend to explicitly reduce
the expressivity of the formalism in order to ensure that unwanted
constructs can not be created by making them untypeable.  This also
makes it easier to prove properties of the calculus.  

\section{A Type System for Nomadic Time}
\label{typesys}

In this final section, we consider the specification of a simple type
system for the calculus, which fulfils two main goals:

\begin{enumerate}
\item It ensures the sanity of a given syntactic construction, which
  is implicit in the earlier examples.  This is primarily achieved by
  ensuring that normal process primitives and the primitives used by
  bouncers remain distinct.  For example, $\tntin{n}.\bin.\nil$ should
  not be a valid bouncer, especially as $\tntin{n}$ suggests that the
  bouncer (and its environ) should move inside $n$.
\item It extends and refines our control over mobility by adding a
      secondary mechanism orthogonal to the use of bouncers.
\end{enumerate}

Our rudimentary type system is inspired in part by those given for the
ambient calculus (see \ref{ambienttypes}), specifically the notion of
groups presented in \cite{ambienttypes} and \cite{m3}.  Each process is
assigned a group type, which determines the use of the mobility
primitives.  Each group is a tuple comprising four sets of environ
names\footnote{Each group $g$ is defined abstractly to be of kind
$Group$.}:

\begin{tabular}{rlcl}
$\quad \bullet$ & $\mathscr{R}$ & -- & Environs in which the process may
 \emph{reside} \\
$\bullet$ & $\mathscr{O}$ & -- & Environs which it may \emph{open} \\
$\bullet$ & $\mathscr{L}$ & -- & Environs which it may \emph{leave} \\
$\bullet$ & $\mathscr{E}$ & -- & Environs which it may \emph{enter}
\end{tabular}

$\mathscr{L}$ and $\mathscr{E}$ form subsets of $\mathscr{R}$, as
clearly, if a process may enter or leave a environ, it must also be able
to reside within it.  As an example, consider the group
$(\{n\},\emptyset, \emptyset,\{n\})$.  Processes of this type may enter
and reside in $n$, but, once there, they may not leave.  They also lack
the ability to destroy $n$.  We write $g(\mathscr{R})$,
$g(\mathscr{O})$, $g(\mathscr{L})$ and $g(\mathscr{E})$ for the
components of the group $g$.

The type system is presented in Table \ref{tab:basictypes}; the general
syntax for a type $T$ is given by

\begin{equation*}\begin{aligned}
T \mathrel{::=} & \quad P \mid Act \mid Clock \mid Name \mid Bouncer \mid
 Environ \\
P \mathrel{::=} & \quad g \mid P \oplus P \mid P \otimes P \mid \pi_L P \mid
 \pi_R P \\
                & \quad \text{where $g \colon Group$ ranges over group types.}
\end{aligned}
\end{equation*}

The rule $Env$ states that if $\xi$ of type $T$ is a member of
$\Gamma$, then a typing derivation $\vdash \xi : T$ may be made in the
context of $\Gamma$.  This forms the basis of all later rules.  Notice
that our system is naturally polymorphic; both $\nil$ and $\Delta$ can
have any group type $g$.  In contrast, $\Omega$ can only be typed as a
$Bouncer$, thus distinguishing it from the behaviourally equivalent
process, $\Delta$.  

The remaining rules allow types to be applied in accordance with the
various operators present in the calculus.  Notice that $Stall$ requires
that $\sigma$ is typeable as a clock, another restriction which makes
explicit a number of issues implied in the syntax.  Similarly, $Act$
requires $\alpha$ to be an action ($Act$) and $Res$ requires the $a$ to
be a $Name$.  When handing the binary operators, we use the rules $SumC$
and $ParC$ to construct appropriate composite types that maintain the
groups used on either side.  The rules $SumL$ and $SumR$ then allow the
appropriate type to be recovered when one of the processes in a
summation evolves.  Notice that no construct is available (none is
needed) for recovering the components of a product type in this system.

\begin{table}
  \caption{Types}
  \label{tab:basictypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
     \Rule{Env}
     {\xi : T \in \Gamma}
     {\Gamma \vdash \xi : T}
     {}
  &
  \Rule{Nil}
     {\Gamma \vdash g : Group}
     {\Gamma \vdash \nil : g}
     {}
  \\[3ex]
     \Rule{BNil}
     {-}
     {\Gamma \vdash \Omega : Bouncer}
     {}
     &
     \Rule{Stop}
     {\Gamma \vdash g : Group}
     {\Gamma \vdash \Delta : g}
     {}
     \\[3ex]
     \Rule{Stall}
     {\Gamma \vdash \sigma : Clock, g : Group}
     {\Gamma \vdash \Delta_\sigma : g}
     {}
     &
     \Rule{Act}
     {\Gamma \vdash \alpha : Act, E : g : Group}
     {\Gamma \vdash \alpha . E : g}
     {}
  \\[3ex]
     \Rule{Rec}
     {\Gamma \vdash E : g : Group}
     {\Gamma \vdash \mu X.E : g}
     {}
     &
     \Rule{Res}
     {\Gamma \vdash a : Name, E : g : Group}
     {\Gamma \vdash E \res{a} : g}
     {}
  \\[3ex]
   \Rule{SumC}
   {\Gamma \vdash E : g : Group, F : g' : Group}
   {\Gamma \vdash E + F : g \oplus g'}
   {}
   &
   \Rule{ParC}
   {\Gamma \vdash E : g : Group, F : g' : Group}
   {\Gamma \vdash E \pc F : g \otimes g'}
   {}
   \\[3ex]
   \Rule{SumL}
   {\Gamma \vdash E + F : g : Group}
   {\Gamma \vdash E' : \pi_{L} g}
   {(E \derives{\kappa} E')}
   &
   \Rule{SumR}
   {\Gamma \vdash E + F : g : Group}
   {\Gamma \vdash F' : \pi_{R} g}
   {(F \derives{\kappa} F')}
   \\[3ex]
 \end{tabular}
  \end{center}
  \shrule
\end{table}

Table \ref{tab:totypes} shows the rules for timeouts.  These follow much
the same design as the rules for the summation operator, except that
they include the additional requirement that $\sigma$ must be typeable
as a clock.  The $STOS$ rule handles the additional eventuality that the
process may evolve with the timeout still in place when using the stable
timeout operator.
 
\begin{table}
  \caption{Timeout Types}
  \label{tab:totypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
  \multicolumn{4}{c}{
   \Rulea{FTOC}
   {\Gamma \vdash E : g : Group, F : g' : Group, \sigma : Clock}
   {\Gamma \vdash \timeout{E}{\sigma}{F} : g \oplus g'}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{STOC}
   {\Gamma \vdash E : g : Group, F : g' : Group, \sigma : Clock}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g \oplus g'}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{FTOL}
   {\Gamma \vdash \timeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash E' : \pi_{L} g}
   {(E \derives{\gamma} E', \gamma \ne \sigma)}
}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{FTOR}
   {\Gamma \vdash \timeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash F : \pi_{R} g}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{STOL}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash E' : \pi_{L} g}
   {(E \derives{\kappa} E')}
  }\\[3ex]
  \multicolumn{4}{c}{
   \Rulea{STOR}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash F : \pi_{R} g}
   {}}
   \\[3ex]
  \multicolumn{4}{c}{
  \Rulea{STOS}
   {\Gamma \vdash \stimeout{E}{\sigma}{F} : g : Group}
   {\Gamma \vdash \stimeout{E'}{\sigma}{F} : g}
   {(E \derives{\rho} E', \rho \ne \sigma)}
  }
  \\[3ex]
 \end{tabular}
  \end{center}
  \shrule
\end{table}

The rules for the bouncers are shown in Table \ref{tab:botypes}, where
$BRec$ allows recursive bouncers to be defined, while $BIn$, $BOut$ and
$BOpen$ allow an existing bouncer, $B$, to be prefixed with one of the
three bouncer primitives ($\bin$, $\bout$ and $\bopen$).  $BSum$ simply
allows the result of composing two bouncers with the summation operator,
$+$ to be typeable as well.

\begin{table}
  \caption{Bouncer Types}
  \label{tab:botypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
  \Rule{BRec}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \mu X.B : Bouncer}
  {}
  &
  \Rule{BIn}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bin .B : Bouncer}
  {}
  \\[3ex]
  \Rule{BOut}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bout .B : Bouncer}
  {}
  &
  \Rule{BOpen}
  {\Gamma \vdash B : Bouncer}
  {\Gamma \vdash \bopen .B : Bouncer}
  {}
  \\[3ex]
  \multicolumn{4}{c}{
   \Rulea{BSum}
   {\Gamma \cup \Gamma^\prime \vdash B : Bouncer,
   \Gamma \cup \Gamma^\prime  \vdash B^\prime : Bouncer}
   {\Gamma \cup \Gamma^\prime \vdash B + B^\prime : Bouncer}
   {}
  }
 \end{tabular}
  \end{center}
  \shrule
\end{table}
 
The mobility types in Table \ref{tab:motypes} form the remaining focus
of our type system; the type $g$ of an environ
$\locv{m}{E}{B}{\vec{\sigma}}$ is that of its encapsulated process $E$,
subject to the constraint $m \in g(\mathscr{R})$. Similar sanity checks
are performed in the other rules. For example, in $Open$, $E$ is the
process that performs the mobility primitive, $\tntopen{m}$ (subject to
the constraint $m \in g(\mathscr{O})$).  However, the destruction of $m$
also has an effect on its process ($F$).  As a result, $F$ must have an
appropriate type, $h$, such that $F$ can reside in the parent environ,
$n$, after $m$ is removed.

\begin{table}
  \caption{Mobility Types}
  \label{tab:motypes}
  \shrule
 \begin{center}
 \begin{tabular}{rlrl}
  \multicolumn{4}{c}{
     \Rulea{Environ}
     {\Gamma \vdash m : Environ,
     \Gamma \vdash E : g : Group,
     \Gamma \vdash B : Bouncer,
     m \in g(\mathscr{R})}
     {\Gamma \vdash \loc{m}{E}{B}{\vec{\sigma}} : g}
     {}
  }
  \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{EnvIn}
     {\Gamma \vdash m : Environ,
  \Gamma \vdash E : g : Group,
  m \in g(\mathscr{E})}
     {\Gamma \vdash \tntin{m}.E : g}
     {}
  }
     \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{EnvOut}
     {\Gamma \vdash \loc{n}{\loc{m}{E}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group,
  m \in g(\mathscr{L}),
  n \in g(\mathscr{E})}
     {\Gamma \vdash \tntout{m}.E : g}
     {}
  }
     \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{Open}
     {\Gamma \vdash \loc{n}{E}{B_1}{\vec{\sigma}} : g : Group,
  \Gamma \vdash \loc{m}{F}{B}{\vec{\sigma}} : h : Group,
  m \in g(\mathscr{O}),
  n \in h(\mathscr{E})}
     {\Gamma \vdash \tntopen{m}.E : g}
     {}
  }
  \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{ProcIn}
  {\Gamma \vdash a : Name,
  \Gamma \vdash \loc{n}{E \mid F \mid \loc{m}{\nil}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group, 
  m \in g(\mathscr{E})}
     {\loc{n}{\procin{a}{m}.E \mid a.F \mid \loc{m}{\nil}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group}
     {}  
  }
  \\[3ex]
  \multicolumn{4}{c}{
     \Rulea{ProcOut}
  {\Gamma \vdash a : Name,
  \Gamma \vdash \locv{n}{\loc{m}{E \mid F}{B_1}{\vec{\sigma}}}{B_2}{\vec{\rho}} : g : Group, 
  m \in g(\mathscr{L}),
  n \in g(\mathscr{E})}
     {\Gamma \vdash \locv{n}{\loc{m}{\procout{a}{m}.E \mid a.F}{B}{\vec{\sigma}}}{B_2}{\vec{\rho}} :
  g}
     {}
  }
 \end{tabular}
  \end{center}
  \shrule
\end{table}

\section{DynamiTE and the Type System}

\section{Conclusion}
