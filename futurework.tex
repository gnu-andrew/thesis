\chapter{Future Work}
\label{futurework}

\section{Introduction}

This chapter briefly discusses possible future work with regard to the
process calculus Nomadic Time (\ref{future:nt}), DynamiTE
(\ref{future:dynamite}) and the type system (\ref{future:types}).  We
also touch on other possible applications for Nomadic Time
(\ref{future:apps}).

\section{Nomadic Time}
\label{future:nt}

\subsection{Separation of Syntax}

At present, the syntax represents bouncers as a form of process for
simplicity.  This has the advantage of being minimal, but also means
that there are number of possible constructs that we would prefer to
deem illegal (e.g. the use of bouncers with the timeout operators or
$\Omega$ being used as a `normal' process term).  In chapter
\ref{tnt}, we showed how the type system could be used to make such
terms invalid, but in hindsight it would better to have a more verbose
syntax which rules these out from the start.

\subsection{Equivalence}
\label{future:equiv}

The main element lacking in the current version of Nomadic Time is
some notion of equivalence.  This is necessary to be able to compare
processes, and brings the additional benefit of being able to reduce
them to a simpler form.  This would also ripple through to DynamiTE in
the implementation of an \texttt{equals} method for the Nomadic Time
implementations of \texttt{Process}, which currently only return true
where both objects are the same instance.

Any bisimulation theory for NT would be based on the labelled
transition system defined by the semantics.  In particular, the
semantics share a lot in common with those of CaSE, for which a form
of bisimulation-based equivalence (\emph{temporal observation
  congruence}) already exists.  Nomadic Time introduces a number of
new transitions, including the three \emph{mobility transitions}
($\tin$, $\tout$ and $\topen$) and the component transitions formed
from terms in $\ambop$ which pair up to generate $\tin$, $\tout$ and
$\topen$.  Thus, any equivalence theory would need to consider issues
such as whether $\tntin{m}$ is equivalent to $\tntin{n}$; do we
consider only that a `in' action is being performed or do we also take
into account the specific environ involved?

Mobility affects the topology of the process, and thus the difference
between two processes may not be fully realised simply by looking at
transitions.  For example,
$\locv{m}{\locv{n}{\tntin{m}.\nil}{\Omega}{\emptyset}}{\Omega}{\emptyset}$
and $\locv{m}{\tntin{m}.\nil}{\Omega}{\emptyset}$ both produce a
$\tntin{m}$ transition along with one for each member of $\timers$.
Assuming $\timers$ is the same for both, the difference in topology is
not discernable from merely the set of possible transitions.

\section{DynamiTE}
\label{future:dynamite}

As we hinted at in chapter \ref{dynamite}, there are still a number of
areas we wish to explore in the future.  These include:

\begin{itemize}
\item The development of further \texttt{Evolver} implementations
  which implement a variety of execution semantics.  This gives the
  possibility of experimenting with additional constraints and levels
  of priority, which may later be formally adopted in the calculus.
\item Expanding the locality framework so that we actually move code
  and data between processes or even hosts via a network.
\item The addition of data to the clock signals, allowing them not
  only to act as phasing signals but also as a mechanism for broadcast
  data.
\item The development of a parser and/or graphical design tool so that
  processes can be constructed from algebraic terms or diagrams,
  rather than Java code.
\end{itemize}

There is also plenty of possibilities for further work in providing
more complex implementations of the plugin services such as
interprocess communication via web services and supporting other
process calculi.  Hopefully, third parties may also wish to get
involved in this area.

\section{The Type System}
\label{future:types}

\subsection{More Advanced Types}

It would be interesting to consider further the typing of both actions
and clocks.  At present, they just have the simplest of types, but
this could be extended to provide more interesting behaviour.
Similarly, bouncers only have rudimentary types and may possibly be
changed to include more detail.

\subsection{Nomadic Time Extended With Data}
\label{tnted}

At present, the calculus does not explicitly represent the passing of
data in any form.  When synchronisation occurs on a channel, $a$, it
simply produces a $\tau$ transition.  Within DynamiTE, the transfer of
a single \texttt{Object} from sender to receipient takes place.  This
is clearly inefficient, and it would be preferable to transfer
multiple items in a single synchronisation.  It would also be
preferable if the type of the data was represented, so that the type
expected by the receiver matches that sent by the sender.

Both of these could be implemented via the type system.  The matching
of the number of items being sent with those received could also be
performed through additions to the syntax and semantics, but also has
the downside of introducing a new set of names; we already have
distinct sets of names ($\names$), co-names ($\conames$) and clocks
($\timers$) along with the names used by environs.

Such an extension would draw on Milner's work on sorts (see
\ref{sorts}) and allow synchronisation to proceed only when the
following holds for $a : \vec{x}$ and $\overline{a} : \vec{y}$:

\begin{enumerate}
\item The length $n$ of $\vec{x}$ ($\#x$) must equal the length of
  $\vec{y}$ ($\#y$).
\item For each element $x_i$ in $\vec{x}$, the corresponding element
  in $\vec{y}$, $y_i$, must have the same type $t_i$.
\end{enumerate}

The types used in $\vec{x}$ and $\vec{y}$ are not members of $T$ (see
\ref{typesys}), but are user-defined.  In DynamiTE, for example, $t_1$
may be \texttt{String}.  Thus if $a$ is defined as having the type
$(t_1, t_2, t_3)$, it can only synchronise with $\overline{a}$ if it
also has the type $(t_1, t_2, t_3)$.  Clearly, the second rule could
be widened to allow a subtyping relation between the two types, rather
than equivalence.

\section{Other Applications}
\label{future:apps}

There may be other domains in which our calculus will find
applicability.  Pervasive computing may be one such area, as may
biological modelling.  In addition, its relation to P systems
(\ref{psystems}) and the ability to encode it using a bigraph
(\ref{bigraphs}) would form interesting areas of study.
