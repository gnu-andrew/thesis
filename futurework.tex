\chapter{Future Work}
\label{futurework}

\section{Introduction}

This chapter briefly discusses possible future work with regard to the
process calculus Nomadic Time (\ref{future:nt}), DynamiTE
(\ref{future:dynamite}) and the type system (\ref{future:types}).  We
also touch on other possible applications for Nomadic Time
(\ref{future:apps}).

\section{Nomadic Time}
\label{future:nt}

\subsection{Separation of Syntax}

At present, the syntax represents bouncers as a form of process for
simplicity.  This has the advantage of being minimal, but also means
that there are number of possible constructs that we would prefer to
deem illegal (e.g. the use of bouncers with the timeout operators or
$\Omega$ being used as a `normal' process term).  In chapter
\ref{tnt}, we showed how the type system could be used to make such
terms invalid, but in hindsight it would better to have a more verbose
syntax which rules these out from the start.

\subsection{Equivalence}
\label{future:equiv}

The main element lacking in the current version of Nomadic Time is
some notion of equivalence.  This is necessary to be able to compare
processes, and brings the additional benefit of being able to reduce
them to a simpler form.  This would also ripple through to DynamiTE in
the implementation of an \texttt{equals} method for the Nomadic Time
implementations of \texttt{Process}, which currently only return true
where both objects are the same instance.

Any bisimulation theory for NT would be based on the labelled
transition system defined by the semantics.  In particular, the
semantics share a lot in common with those of CaSE, for which a form
of bisimulation-based equivalence (\emph{temporal observation
  congruence}) already exists.  Nomadic Time introduces a number of
new transitions, including the three \emph{mobility transitions}
($\tin$, $\tout$ and $\topen$) and the component transitions formed
from terms in $\ambop$ which pair up to generate $\tin$, $\tout$ and
$\topen$.  Thus, any equivalence theory would need to consider issues
such as whether $\tntin{m}$ is equivalent to $\tntin{n}$; do we
consider only that an `in' action is being performed or do we also take
into account the specific environ involved?

Mobility affects the topology of the process, and thus the difference
between two processes may not be fully realised simply by looking at
transitions.  For example,
$\locv{m}{\locv{n}{\tntin{m}.\nil}{\Omega}{\emptyset}}{\Omega}{\emptyset}$
and $\locv{m}{\tntin{m}.\nil}{\Omega}{\emptyset}$ both produce a
$\tntin{m}$ transition along with one for each member of $\timers$.
Assuming $\timers$ is the same for both, the difference in topology is
not discernable from merely the set of possible transitions.

\section{DynamiTE}
\label{future:dynamite}

As we hinted at in chapter \ref{dynamite}, there are still a number of
areas we wish to explore in the future.  These include:

\begin{itemize}
\item The development of further \texttt{Evolver} implementations
  which implement a variety of execution semantics.  This gives the
  possibility of experimenting with additional constraints and levels
  of priority, which may later be formally adopted in the calculus.
\item Expanding the locality framework so that we actually move code
  and data between processes or even hosts via a network.
\item The addition of data to the clock signals, allowing them not
  only to act as phasing signals but also as a mechanism for broadcast
  data.
\item The development of a parser and/or graphical design tool so that
  processes can be constructed from algebraic terms or diagrams,
  rather than Java code.
\end{itemize}

There are also plenty of possibilities for further work in providing
more complex implementations of the plugin services such as
interprocess communication via web services and supporting other
process calculi.  Hopefully, third parties may also wish to get
involved in this area.

\section{The Type System}
\label{future:types}

\subsection{More Advanced Types}

There are a number of ideas that could be further investigated:

\begin{itemize}
\item The addition of types to actions and/or clocks.  In \ref{tnted},
  we explore one possibility for the former, but there may be more.
\item Bouncers only have a single rudimentary type; this could be
  extended.  Alternatively, the syntactic form of bouncers could be
  removed altogether, with the same functionality instead being
  provided by the type system.
\item It may be worth implementing the types in a theorem prover and
  deducing results, such as proofs of consistency.
\end{itemize}

\subsection{Nomadic Time Extended With Data}
\label{tnted}

At present, the calculus does not explicitly represent the passing of
data in any form.  When synchronisation occurs on a channel, $a$, it
simply produces a $\tau$ transition.  Within DynamiTE, the transfer of
a single \texttt{Object} from sender to reciepient takes place.  This
may be inefficient if many objects need to be sent, and it would be
preferable to transfer multiple items in a single synchronisation.  It
would also be preferable if the type of the data was represented, so
that the type expected by the receiver matches that sent by the
sender.

Both of these could be implemented via the type system.  The matching
of the number of items being sent with those received could also be
performed through additions to the syntax and semantics, but also has
the downside of introducing a new set of names; we already have
distinct sets of names ($\names$), co-names ($\conames$) and clocks
($\timers$) along with the names used by environs.

Such an extension would draw on Milner's work on sorts (see
\ref{sorts}) and allow synchronisation to proceed only when the
following holds for $a : \vec{x}$ and $\overline{a} : \vec{y}$:

\begin{enumerate}
\item The length $n$ of $\vec{x}$ ($\#x$) must equal the length of
  $\vec{y}$ ($\#y$).
\item For each element $x_i$ in $\vec{x}$, the corresponding element
  in $\vec{y}$, $y_i$, must have the same type $t_i$.
\end{enumerate}

The types used in $\vec{x}$ and $\vec{y}$ are not members of $T$ (see
\ref{typesys}), but are user-defined.  In DynamiTE, for example, $t_1$
may be \texttt{String}.  Thus if $a$ is defined as having the type
$(t_1, t_2, t_3)$, it can only synchronise with $\overline{a}$ if it
also has the type $(t_1, t_2, t_3)$.  Clearly, the second rule could
be widened to allow a subtyping relation between the two types, rather
than equivalence.

\subsection{Explicit Type Assignment}

At present, there is no explicit assignment of types to processes in
the type system.  We assume that the user either adds their own axioms
to fix the type of a process, or that the type of a process is
derived; for example, we can derive a suitable type for
$\tntin{m}.\nil$ through the knowledge that $m \in g(\mathscr{R})$
must hold.  In the DynamiTE implementation of the type system (see
\ref{dyn:type}), types are assigned when constructing \texttt{Nil},
\texttt{Delta}, \texttt{Stall} and \texttt{Var} instances.  This could
also be added to the formal version by modifying the syntax and
semantics to use $\nil : T$, $\Delta : T$ and $\Delta_\sigma : T$.

\section{Other Applications}
\label{future:apps}

There may be other domains in which our calculus will find
applicability.  Pervasive computing may be one such area, as may web
services and biological modelling.  In addition, its relation to P
systems (\ref{psystems}) and the ability to encode it using a bigraph
(\ref{bigraphs}) would form interesting areas of study.
